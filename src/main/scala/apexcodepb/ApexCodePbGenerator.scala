package apexcodepb

import com.google.protobuf.Descriptors.{ Descriptor, FieldDescriptor, FileDescriptor }
import com.google.protobuf.WireFormat.FieldType
import com.google.protobuf.{ CodedInputStream, ExtensionRegistry }
import com.google.protobuf.compiler.PluginProtos.{ CodeGeneratorRequest, CodeGeneratorResponse }

import scala.collection.JavaConverters._

object ApexCodePbGenerator {

  implicit class ImplicitMessageDescriptor(val message: Descriptor) {
    def fields =
      message.getFields.asScala.filter(_.getLiteType != FieldType.GROUP).toSeq
  }

  def snakeCaseToCamelCase(name: String, upperInitial: Boolean = false): String = {
    val b = new StringBuilder()
    @annotation.tailrec
    def inner(name: String, index: Int, capNext: Boolean): Unit = if (name.nonEmpty) {
      val (r, capNext2) = name.head match {
        case c if c.isLower => (Some(if (capNext) c.toUpper else c), false)
        case c if c.isUpper =>
          // force first letter to lower unless forced to capitalize it.
          (Some(if (index == 0 && !capNext) c.toLower else c), false)
        case c if c.isDigit => (Some(c), true)
        case _              => (None, true)
      }
      r.foreach(b.append)
      inner(name.tail, index + 1, capNext2)
    }
    inner(name, 0, upperInitial)
    b.toString
  }

  def toApexType(field: FieldDescriptor): String =
    field.getJavaType match {
      case FieldDescriptor.JavaType.INT     => "Integer"
      case FieldDescriptor.JavaType.DOUBLE  => "Double"
      case FieldDescriptor.JavaType.FLOAT   => "Double"
      case FieldDescriptor.JavaType.BOOLEAN => "Boolean"
      case FieldDescriptor.JavaType.MESSAGE =>
        field.getMessageType.getName
      case _ => toCamelCase(field.getJavaType.name)
    }

  def toCamelCase(name: String): String = s"""${name.head.toUpper}${name.tail.toLowerCase()}"""

  def toApexCodeFileName(name: String) =
    name.split("/").last.replaceAll(raw"[.]proto$$|[.]protodevel", "")

  def printMessage(printer: FunctionalPrinter, message: Descriptor): FunctionalPrinter = {
    printer
      .add(s"public class ${message.getName} {")
      .indent
      .print(message.fields) {
        case (printer, field) =>
          printer.add(
            s"public ${toApexType(field)} ${snakeCaseToCamelCase(field.getName, false)} { get; set; }"
          )
      }
      .outdent
      .add(s"}".stripMargin)
  }

  def run(input: CodedInputStream): Array[Byte] = {
    try {

      val registry = ExtensionRegistry.newInstance
      val request  = CodeGeneratorRequest.parseFrom(input, registry)

      val b = CodeGeneratorResponse.newBuilder

      val filesByName: Map[String, FileDescriptor] =
        request.getProtoFileList.asScala.foldLeft[Map[String, FileDescriptor]](Map.empty) {
          case (acc, fp) =>
            val deps = fp.getDependencyList.asScala.map(acc)
            acc + (fp.getName -> FileDescriptor.buildFrom(fp, deps.toArray))
        }

      request.getFileToGenerateList.asScala.foreach { name =>
        val file: FileDescriptor = filesByName(name)
        val code = new FunctionalPrinter()
          .add(s"""// Generated by the ApexCodePB for the Protocol Buffer Compiler.
                  |// Do not edit!
                  |//
                  |// Protofile syntax: ${file.getSyntax.toString}
                  |""".stripMargin)
          .print(file.getMessageTypes.asScala)(printMessage)
          .result()

        val tempB = CodeGeneratorResponse.File.newBuilder()
        tempB.setName(snakeCaseToCamelCase(toApexCodeFileName(file.getName), true) + ".cls")
        tempB.setContent(code)
        b.addAllFile(Seq(tempB.build()).asJava)
      }
      b.build.toByteArray
    } catch {
      case t: Throwable =>
        CodeGeneratorResponse.newBuilder.setError(t.toString).build.toByteArray
    }
  }
}
